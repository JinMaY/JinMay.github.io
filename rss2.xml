<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Daily Programming</title>
    <link>https://jinmay.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 28 May 2020 04:25:09 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[python]리스트 컴프리핸션에서 if문 사용하기</title>
      <link>https://jinmay.github.io/2020/05/28/python/python-list-comprehension-with-if-statement/</link>
      <guid>https://jinmay.github.io/2020/05/28/python/python-list-comprehension-with-if-statement/</guid>
      <pubDate>Thu, 28 May 2020 02:17:08 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;리스트 컴프리핸션(list comprehension)이란 pythonic 하다고 표현되는 대표적인 문법 중에 하나이다. 꽤 간단한 방법으로 리스트를 만들 수 있다는 장점이 있다. 기본적으로 for문을 사용하기 때문에 반복할 수 있는 iterato
        
      
      </description>
      
      <content:encoded><![CDATA[<p>리스트 컴프리핸션(list comprehension)이란 pythonic 하다고 표현되는 대표적인 문법 중에 하나이다. 꽤 간단한 방법으로 리스트를 만들 수 있다는 장점이 있다. 기본적으로 for문을 사용하기 때문에 반복할 수 있는 iterator나 generator와 함께 사용되는 것이 일반적이다.</p><p>list comprehension을 사용할때 if문을 사용하면 조건에 맞는 데이터를 가지고 리스트를 만들 수 있는데 이때 if문을 사용하는 방법에는 두 가지 정도가 있는 것 같다. 이 두 가지 방법에 대해서 정리한다.</p><h2 id="조건에-맞는-리스트-만들기"><a href="#조건에-맞는-리스트-만들기" class="headerlink" title="조건에 맞는 리스트 만들기"></a>조건에 맞는 리스트 만들기</h2><p>만약 <code>a</code>라는 리스트에서 짝수인 데이터만 가지고 새로운 리스트(<code>b</code>)를 만들어야 한다면 아래와 같이 할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">b = [num <span class="keyword">for</span> num <span class="keyword">in</span> a <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>for문 뒤에 if문을 적어주면 된다.</p><h2 id="삼항연상-이용"><a href="#삼항연상-이용" class="headerlink" title="삼항연상 이용"></a>삼항연상 이용</h2><p><code>if ... else ...</code> 삼항연산을 이용하면 조건에 해당할 때와 해당하지 않을때에 대해서 리스트 컴프리핸션을 사용할 수 있다. 짝수면 그대로 두고 홀 수 일때 10을 곱하는 컴프리핸션은 다음과 같이 작성할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">b = [</span><br><span class="line">    num <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> num * <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> a</span><br><span class="line">]</span><br><span class="line"><span class="comment"># [10, 2, 30, 4, 50, 6, 70, 8, 90, 10]</span></span><br></pre></td></tr></table></figure><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>리스트를 만들때 조건이 복잡하지 않다면 리스트 컴프리핸션을 사용하는 것이 권장된다. 간단한 조건이라면 삼항연산과 함께 리스트 컴프리핸션을 사용해도 되지만 그렇지 않을 경우 조건을 판단하는 함수를 따로 만들어서 삼항 연산을 대체하거나 다른 방법을 찾는 것이 좋을 것 같다.</p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/28/python/python-list-comprehension-with-if-statement/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Django]values와 values_list의 차이</title>
      <link>https://jinmay.github.io/2020/05/25/django/django-values-and-values-list/</link>
      <guid>https://jinmay.github.io/2020/05/25/django/django-values-and-values-list/</guid>
      <pubDate>Mon, 25 May 2020 07:34:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Django ORM 최적화 중 하나로서 필요한 필드의 값만 가져오기 위해 &lt;code&gt;values()&lt;/code&gt;와 &lt;code&gt;values_list()&lt;/code&gt;를 사용한다. 각 메소드의 결과는 어떻게 생겼고 차이점이 무엇인지 정리해본다.&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Django ORM 최적화 중 하나로서 필요한 필드의 값만 가져오기 위해 <code>values()</code>와 <code>values_list()</code>를 사용한다. 각 메소드의 결과는 어떻게 생겼고 차이점이 무엇인지 정리해본다.</p><h3 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h3><p>쿼리셋의 값을 딕셔너리 형태로 반환한다. queryset에 대해서 사용하기 때문에 순서는 그닥 상관 없는 것 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Post.objects.values().filter(id__lt=<span class="number">8</span>)</span><br><span class="line"><span class="comment"># &lt;QuerySet [&#123;'id': 5, 'title': 'post #1'&#125;, &#123;'id': 6, 'title': 'title #1'&#125;, &#123;'id': 7, 'title': 'title #2'&#125;]&gt;</span></span><br><span class="line"></span><br><span class="line">Post.objects.filter(id__lt=<span class="number">8</span>).values()</span><br><span class="line"><span class="comment"># &lt;QuerySet [&#123;'id': 5, 'title': 'post #1'&#125;, &#123;'id': 6, 'title': 'title #1'&#125;, &#123;'id': 7, 'title': 'title #2'&#125;]&gt;</span></span><br></pre></td></tr></table></figure><p>만약 아래와 같이 <code>values()</code> 메소드에 인자로서 필드명을 넣으면 <code>필드: 값</code>의 형태로 가져올 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Post.objects.filter(id__lt=<span class="number">8</span>).values(<span class="string">'title'</span>)</span><br><span class="line"><span class="comment"># &lt;QuerySet [&#123;'title': 'post #1'&#125;, &#123;'title': 'title #1'&#125;, &#123;'title': 'title #2'&#125;]&gt;</span></span><br></pre></td></tr></table></figure><h3 id="values-list"><a href="#values-list" class="headerlink" title="values_list()"></a>values_list()</h3><p>쿼리셋의 값을 튜플 형태로 반환한다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Post.objects.filter(id__lt=<span class="number">8</span>).values_list()</span><br><span class="line"><span class="comment"># &lt;QuerySet [(5, 'post #1'), (6, 'title #1'), (7, 'title #2')]&gt;</span></span><br></pre></td></tr></table></figure><p>마찬가지로 <code>values_list()</code>에 인자로서 필드를 넣으면 해당 필드의 값만 튜플로 반환한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Post.objects.filter(id__lt=<span class="number">8</span>).values_list(<span class="string">'title'</span>)</span><br><span class="line"><span class="comment"># &lt;QuerySet [('post #1',), ('title #1',), ('title #2',)]&gt;</span></span><br></pre></td></tr></table></figure><p><code>values_list()</code>에는 필드명 이외에 <code>flat</code>이라는 인자를 사용할 수 있다. <code>flat</code>은 Boolean 타입이며 기본값은 <code>False</code>이다. <code>flat</code>의 역할은 튜플이 아닌 리스트로 필드의 값을 반환하는 것이다. 주의사항으로 <code>flat</code> 인자는 필드가 여러개일때 사용할 수 없다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Post.objects.filter(id__lt=<span class="number">8</span>).values_list(flat=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># &lt;QuerySet [5, 6, 7]&gt;</span></span><br><span class="line"></span><br><span class="line">Post.objects.filter(id__lt=<span class="number">8</span>).values_list(<span class="string">'title'</span>, flat=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># &lt;QuerySet ['post #1', 'title #1', 'title #2']&gt;</span></span><br></pre></td></tr></table></figure><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>ORM을 사용하면 매우 편리하게 DB를 사용할 수 있어서 좋지만 때로는 비합리적으로 동작할때가 있어 대용량 데이터를 다룰때 문제가 될 수 있다. <code>values()</code>와 <code>values_list()</code>는 ORM 쿼리 최적화의 방법 중 하나로서 필요한 필드의 값만 가져올 수 있고, 따라서 DB에 부하를 줄일 수 있다는 점을 알고 있자.</p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/25/django/django-values-and-values-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Django]not 연산으로 조건 부정하기</title>
      <link>https://jinmay.github.io/2020/05/25/django/how-to-not-equal-query-django-filter/</link>
      <guid>https://jinmay.github.io/2020/05/25/django/how-to-not-equal-query-django-filter/</guid>
      <pubDate>Mon, 25 May 2020 06:13:19 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Django에서 not 연산을 사용하기 위해서는 다음과 같은 연산자를 사용한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;not&lt;/li&gt;
&lt;li&gt;~&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;if문과 같은 조건절이라면 not을 사용할 수 있지만 &lt;code&gt;queryset.filte
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Django에서 not 연산을 사용하기 위해서는 다음과 같은 연산자를 사용한다.</p><ol><li>not</li><li>~</li></ol><p>if문과 같은 조건절이라면 not을 사용할 수 있지만 <code>queryset.filter()</code>나 <code>queryset.get()</code>에서는 어떻게 해야할까?</p><p>Django에서 not 연산을 사용하기 위해서는 아래의 두 메소드를 사용하면 된다.</p><ol><li>exclude()</li><li>filter(~Q(조건))</li></ol><p><code>exclude()</code>의 경우 queryset에서는 기본적으로 사용가능하며, <code>~Q(조건)</code>의 형태로 사용하려면 Q를 임포트해야한다.<br>(<code>from django.db.models import Q</code> 임포트 문을 통해 가져올 수 있다.)</p><h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude()"></a>exclude()</h3><p>기본적으로 queryset의 객체라면 not 연산을 사용하기 위해서 exclude() 메소드를 사용할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projects = Project.objects.exclude(title__startswith=<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure><h3 id="Q-condition"><a href="#Q-condition" class="headerlink" title="~Q(condition)"></a>~Q(condition)</h3><p>Q를 임포트하여 <code>~</code> 기호를 사용해 not 연산을 할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line">projects = Projects.objects.filter(~Q(title__startswith=<span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure><hr><p>[참고]<br><a href="https://django-orm-cookbook-ko.readthedocs.io/en/latest/notequal_query.html" target="_blank" rel="external nofollow noopener noreferrer">https://django-orm-cookbook-ko.readthedocs.io/en/latest/notequal_query.html</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/25/django/how-to-not-equal-query-django-filter/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[git]원격 저장소의 branch 가져오기</title>
      <link>https://jinmay.github.io/2020/05/25/git/git-pull-branch-from-remote/</link>
      <guid>https://jinmay.github.io/2020/05/25/git/git-pull-branch-from-remote/</guid>
      <pubDate>Mon, 25 May 2020 02:54:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;원격 저장소의 branch의 이름을 가지고 로컬로 가져오는 방법을 정리한다.&lt;/p&gt;
&lt;h3 id=&quot;원격-저장소-branch를-로컬로-가져오기&quot;&gt;&lt;a href=&quot;#원격-저장소-branch를-로컬로-가져오기&quot; class=&quot;headerlink&quot; tit
        
      
      </description>
      
      <content:encoded><![CDATA[<p>원격 저장소의 branch의 이름을 가지고 로컬로 가져오는 방법을 정리한다.</p><h3 id="원격-저장소-branch를-로컬로-가져오기"><a href="#원격-저장소-branch를-로컬로-가져오기" class="headerlink" title="원격 저장소 branch를 로컬로 가져오기"></a>원격 저장소 branch를 로컬로 가져오기</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -t &lt;원격저장소 branch 이름&gt;</span><br></pre></td></tr></table></figure><p>위와 같이 입력하면 된다. 예를 들어, 원격저장소의 nickname이 <code>origin</code>이고 branch가 <code>git-practice</code>라면 아래와 같이 입력한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -t origin/git-practice</span><br></pre></td></tr></table></figure><h3 id="결론"><a href="#결론" class="headerlink" title="결론..?"></a>결론..?</h3><p>로컬에서 작업하던 내용(branch)를 모두 지우고 새로 시작하고 싶을때 사용하면 좋을 것 같다.</p><hr><p>[참고]<br><a href="https://cjh5414.github.io/get-git-remote-branch/" target="_blank" rel="external nofollow noopener noreferrer">https://cjh5414.github.io/get-git-remote-branch/</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/25/git/git-pull-branch-from-remote/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Django]CharField와 TextField에서의 null=True</title>
      <link>https://jinmay.github.io/2020/05/25/django/django-charfield-textfield-null/</link>
      <guid>https://jinmay.github.io/2020/05/25/django/django-charfield-textfield-null/</guid>
      <pubDate>Mon, 25 May 2020 02:16:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Django에서 필수필드로 만들지 않기 위해 보통은 &lt;code&gt;null=True, blank=True&lt;/code&gt;로 두는 경우가 많다. 대개의 경우에는 문제가 되지 않지만 문자열 기반 필드인 &lt;code&gt;CharField / TextField&lt;/c
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Django에서 필수필드로 만들지 않기 위해 보통은 <code>null=True, blank=True</code>로 두는 경우가 많다. 대개의 경우에는 문제가 되지 않지만 문자열 기반 필드인 <code>CharField / TextField</code>에 <code>null=True</code>를 두는 것을 피하는게 좋다고 한다.</p><p>다시 말해, 문자열 기반인 아래의 필드들은 <code>null=True</code>를 사용하지 않는 게 권장된다.</p><ul><li>CharField</li><li>TextField</li><li>SlugField</li><li>EmailField</li><li>CommaSeparatedIntegerField</li><li>UUIDField</li></ul><p>그 이유는 다음과 같다.</p><p><strong>Django 표준은 빈 값을 빈 문자열로 저장하는 것이며 일관성을 위해서 null값과 빈 값을 빈 문자열을 통해 저장하는 것이다.</strong></p><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>자주 사용되는 <code>CharField / TextField</code>에 대해서는 <code>null=True</code>는 사용하지 말자. 해당 필드를 필수로 만들지 않으려면 <code>blank=True</code>를 사용하면된다. 이렇게 설정하면 DB에서는 빈 값이 빈 문자열(‘’)로 설정되어 null과 빈 값을 빈 문자열으로만 판단할 수 있게 된다는 장점을 가질 수 있다.</p><hr><p>[참고]<br><a href="https://docs.djangoproject.com/en/3.0/ref/models/fields/#null" target="_blank" rel="external nofollow noopener noreferrer">https://docs.djangoproject.com/en/3.0/ref/models/fields/#null</a><br>two scoops of django</p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/25/django/django-charfield-textfield-null/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[vscode]코드 블록 접기 / 펼치기</title>
      <link>https://jinmay.github.io/2020/05/21/etc/vs-code-collapse-blocks/</link>
      <guid>https://jinmay.github.io/2020/05/21/etc/vs-code-collapse-blocks/</guid>
      <pubDate>Thu, 21 May 2020 14:35:15 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;하나의 파일에 코드의 길이가 길때 다른 부분을 참고해가면서 코딩하기 어려울 때가 종종 있다. 모든 코드 블록을 접고 필요한 부분만 펴서 보면 좋을 것 같아서 단축키를 정리해본다.&lt;/p&gt;
&lt;h3 id=&quot;모든-코드-블록-접기&quot;&gt;&lt;a href=&quot;#모든
        
      
      </description>
      
      <content:encoded><![CDATA[<p>하나의 파일에 코드의 길이가 길때 다른 부분을 참고해가면서 코딩하기 어려울 때가 종종 있다. 모든 코드 블록을 접고 필요한 부분만 펴서 보면 좋을 것 같아서 단축키를 정리해본다.</p><h3 id="모든-코드-블록-접기"><a href="#모든-코드-블록-접기" class="headerlink" title="모든 코드 블록 접기"></a>모든 코드 블록 접기</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># macOS</span></span><br><span class="line"><span class="built_in">command</span> + K + 0(숫자 0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Window</span></span><br><span class="line">control + K + 0(숫자 0)</span><br></pre></td></tr></table></figure><h3 id="모든-코드-블록-펼치기"><a href="#모든-코드-블록-펼치기" class="headerlink" title="모든 코드 블록 펼치기"></a>모든 코드 블록 펼치기</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># macOS</span></span><br><span class="line"><span class="built_in">command</span> + K + J</span><br><span class="line"></span><br><span class="line"><span class="comment"># Window</span></span><br><span class="line">control + K + J</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/21/etc/vs-code-collapse-blocks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[git]가장 최근 커밋의 커밋 메세지 수정하기</title>
      <link>https://jinmay.github.io/2020/05/20/git/how-to-amend-git-commit/</link>
      <guid>https://jinmay.github.io/2020/05/20/git/how-to-amend-git-commit/</guid>
      <pubDate>Wed, 20 May 2020 13:36:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;commit 메세지를 수정해야 하는 상황이 자주 발생하지는 않았다. 개인적인 경험으로는 주로 커밋 메세지를 수정해야 하는 상황은 여러개의 commit을 squash한 뒤에 메세지를 수정하고 remote로 push 하는 상황이었다.&lt;/p&gt;
&lt;p&gt;가
        
      
      </description>
      
      <content:encoded><![CDATA[<p>commit 메세지를 수정해야 하는 상황이 자주 발생하지는 않았다. 개인적인 경험으로는 주로 커밋 메세지를 수정해야 하는 상황은 여러개의 commit을 squash한 뒤에 메세지를 수정하고 remote로 push 하는 상황이었다.</p><p>가장 최큰 commit의 메세지를 수정하는 방법에 대해서 알아보자.</p><h3 id="커밋-메세지-수정하기"><a href="#커밋-메세지-수정하기" class="headerlink" title="커밋 메세지 수정하기"></a>커밋 메세지 수정하기</h3><p>커밋 메세지를 수정하기 위해서는 <code>git commit</code> 명령어에 옵션이 필요하다. 이 때, 필요한 옵션은 <code>--amend</code>이다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p><code>--amend</code> 옵션을 적고 commit을 하면 최근 커밋 메세지가 vim과 같은 편집기에 다시 한 번 나오는데, 메세지를 수정하고 저장하면 된다.</p><p>만약 remote로 이미 push를 한 상태라면 주의해야한다. 커밋 메세지를 수정하는 작업은 commit의 hash id가 달라지게 되므로 <code>force push</code>를 해주어야 하는데, 이 작업은 remote git의 commit 이력을 덮어쓰기할 수 있어서 매우 조심해야한다.</p><p>위와 같은 상황에서 remote로 push를 해야겠다면 아래와 같이 입력하자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f &lt;remote_name&gt; &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p><strong>다시 한번 강조하지만 <code>force push</code>하는 과정은 remote git 커밋 이력을 덮어쓰기 할 수 있으므로 주의해야 한다~~</strong></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/20/git/how-to-amend-git-commit/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[mysql]macOS에서 brew로 mysql 설치할때 주의할 점</title>
      <link>https://jinmay.github.io/2020/05/18/mysql/fix-error-installing-mysql-on-mac/</link>
      <guid>https://jinmay.github.io/2020/05/18/mysql/fix-error-installing-mysql-on-mac/</guid>
      <pubDate>Mon, 18 May 2020 14:44:47 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;brew install 명령어를 통해 mysql을 설치할 때, 가끔 알 수 없는 에러가 발생할 때가 있다. openssl을 재설치해보고 git과 gcc 등을 다시 설치해보아도 해결 할 수 없었던 적이 있는데 생각외로 간단하게 해결할 수 있었다.&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>brew install 명령어를 통해 mysql을 설치할 때, 가끔 알 수 없는 에러가 발생할 때가 있다. openssl을 재설치해보고 git과 gcc 등을 다시 설치해보아도 해결 할 수 없었던 적이 있는데 생각외로 간단하게 해결할 수 있었다.</p><h3 id="설치시-에러-고치기"><a href="#설치시-에러-고치기" class="headerlink" title="설치시 에러 고치기"></a>설치시 에러 고치기</h3><p>mysql을 설치하고 나면 <code>export ~~</code> 하는 구문이 뜨는데, 영어라고 대충 읽고 넘어가지 말고 실행을 해주면 큰 문제 없이 작동한다.</p><p>또는,</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install openssl</span><br><span class="line"></span><br><span class="line">LDFLAGS=-L/usr/<span class="built_in">local</span>/opt/openssl/lib pip install mysqlclient</span><br></pre></td></tr></table></figure><hr><p>[참고]<br><a href="https://medium.com/@shandou/pipenv-install-mysqlclient-on-macosx-7c253b0112f2" target="_blank" rel="external nofollow noopener noreferrer">https://medium.com/@shandou/pipenv-install-mysqlclient-on-macosx-7c253b0112f2</a><br><a href="https://medium.com/@elastic7327/osx-mojave-%EC%97%90%EC%84%9C-python-%ED%8C%A8%ED%82%A4%EC%A7%80-mysqlclient%EA%B0%80-%EC%84%A4%EC%B9%98%EA%B0%80-%EC%95%88%EB%90%98%EB%8A%94-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95-2269bcf49c33" target="_blank" rel="external nofollow noopener noreferrer">https://medium.com/@elastic7327/osx-mojave-%EC%97%90%EC%84%9C-python-%ED%8C%A8%ED%82%A4%EC%A7%80-mysqlclient%EA%B0%80-%EC%84%A4%EC%B9%98%EA%B0%80-%EC%95%88%EB%90%98%EB%8A%94-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95-2269bcf49c33</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/18/mysql/fix-error-installing-mysql-on-mac/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[vim] nvim 사용시 vimrc를 통해 설정하기</title>
      <link>https://jinmay.github.io/2020/05/18/linux/vimrc-to-nvimrc/</link>
      <guid>https://jinmay.github.io/2020/05/18/linux/vimrc-to-nvimrc/</guid>
      <pubDate>Mon, 18 May 2020 14:30:35 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;vim보다 가볍다는 이유로 nvim을 사용중이다.&lt;del&gt;(사실 둘의 차이를 느끼지는 못한다.)&lt;/del&gt; vim과 nvim의 설정파일이 나누어져 있는데, 같은 편집기끼리 설정을 나누어서 하고 싶진 않았다. 역시나 비슷한 생각을 가진 개발자들은 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>vim보다 가볍다는 이유로 nvim을 사용중이다.<del>(사실 둘의 차이를 느끼지는 못한다.)</del> vim과 nvim의 설정파일이 나누어져 있는데, 같은 편집기끼리 설정을 나누어서 하고 싶진 않았다. 역시나 비슷한 생각을 가진 개발자들은 많았고 간단한 설정을 통해 해결할 수 있었다.  </p><p>보통 vim / nvim의 설정파일 경로는 아래와 같다.</p><ul><li>vim 설정파일 경로 : ~/.vimrc</li><li>nvim 설정파일 경로 : ~/.config/nvim/init.vim</li></ul><p>nvim의 설정파일에 다음의 세 줄을 적어주면 <code>~/.vimrc</code>에서 nvim 설정을 할 수 있다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> runtimepath+=~/.vim,~/.vim/after</span><br><span class="line"><span class="built_in">set</span> packpath+=~/.vim</span><br><span class="line"><span class="built_in">source</span> ~/.vimrc</span><br></pre></td></tr></table></figure><hr><p>[참고]<br><a href="https://vi.stackexchange.com/questions/12794/how-to-share-config-between-vim-and-neovim" target="_blank" rel="external nofollow noopener noreferrer">https://vi.stackexchange.com/questions/12794/how-to-share-config-between-vim-and-neovim</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/18/linux/vimrc-to-nvimrc/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DNS]ip 주소와 hosts 파일</title>
      <link>https://jinmay.github.io/2020/05/13/web/hosts-file/</link>
      <guid>https://jinmay.github.io/2020/05/13/web/hosts-file/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;서비스를 제공하는 서버 컴퓨터에 접속을 하기 위해서는 서버의 ip 주소를 알아야 한다. 또한 서버가 클라이언트에게 서비스를 제공하려면 서비스를 받을 클라이언트 또한 ip 주소를 가져야한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;즉, 인터넷에 연결되어 있는 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>서비스를 제공하는 서버 컴퓨터에 접속을 하기 위해서는 서버의 ip 주소를 알아야 한다. 또한 서버가 클라이언트에게 서비스를 제공하려면 서비스를 받을 클라이언트 또한 ip 주소를 가져야한다.</p><p><strong>즉, 인터넷에 연결되어 있는 장치들은 통신을 하기 위해서 ip를 가져야한다.</strong>(컴퓨터 뿐만 아니라 모든 장치들에 해당한다.) 이렇게 인터넷에 연결된 장치들을 host라고 부르며 네트워크에 연결되어 있는 컴퓨터 또는 장치라고 생각하면 된다.</p><p><img src="https://user-images.githubusercontent.com/13075035/75006044-c76e5f80-54b3-11ea-8260-da19fbbcc11a.png" alt></p><p>ip주소는 숫자로 되어 있기 때문에 기억하기 어렵다는 단점이 있는데, 이를 해소하기 위해 hosts 파일을 사용한다.</p><p><img src="https://user-images.githubusercontent.com/13075035/75006098-f08ef000-54b3-11ea-8224-1aef114c2133.png" alt></p><p>hosts 파일은 핸드폰의 전화번호부와 비슷하다고 생각하면 된다. 전화번호에 이름을 부여해서 사용하는 것처럼 컴퓨터는 hosts 파일에 ip주소에 해당하는 도메인 주소를 부여해서 저장하고 관리한다.</p><p>추후에 example.com에 접속하면 사용자의 컴퓨터는 DNS를 거치지 않고 hosts 파일에 저장되어 있는 내용을 통해 example.com이 가르키는 ip로 접속할 수 있다.</p><p><strong>또한 별거 아닌 것 같지만 hosts 파일의 보안에 신경써야한다.</strong> 만약 hosts 파일이 변조되어 example.com의 ip 주소가 피싱하려고 만든 서비스의 ip주소로 바뀌면 어떻게 될까? 사용자는 example.com를 제대로 입력했다고 생각했기 때문에 정상적인 사이트로 판단하고 피싱을 당할 지도 모른다.</p><p><img src="https://user-images.githubusercontent.com/13075035/75006972-fafeb900-54b6-11ea-8bb8-2a432294bff0.png" alt></p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>DNS에 대해 알아보기 전에 DNS에 비슷한 역할을 하는 hosts 파일에 대해서 알아보았다. hosts 파일은 ip주소와 도메인 주소를 매칭시켜주는 역할을 하며, 클라이언트가 서비스에 접속하기 위해서 ip 주소를 외워야 하는 불편함을 간단하게 해소시켜준다.</p><hr><p>[참고]<br><a href="https://opentutorials.org/module/3421/20296" target="_blank" rel="external nofollow noopener noreferrer">https://opentutorials.org/module/3421/20296</a><br><a href="https://www.youtube.com/watch?v=viy1MV_vNXA&amp;list=PLuHgQVnccGMCI75J-rC8yZSVGZq3gYsFp&amp;index=2" target="_blank" rel="external nofollow noopener noreferrer">https://www.youtube.com/watch?v=viy1MV_vNXA&amp;list=PLuHgQVnccGMCI75J-rC8yZSVGZq3gYsFp&amp;index=2</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/web/hosts-file/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Web]쿠키와 세션</title>
      <link>https://jinmay.github.io/2020/05/13/web/cookies-and-session/</link>
      <guid>https://jinmay.github.io/2020/05/13/web/cookies-and-session/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;쿠키와 세션은 HTTP를 가지고 통신할때 발생할 수 있는 단점들을 보안할때 자주 사용되곤 한다.&lt;/p&gt;
&lt;p&gt;HTTP의 두 가지 특성은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비연결성(connectionless)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>쿠키와 세션은 HTTP를 가지고 통신할때 발생할 수 있는 단점들을 보안할때 자주 사용되곤 한다.</p><p>HTTP의 두 가지 특성은 아래와 같다.</p><ul><li>비연결성(connectionless)</li></ul><p>HTTP 통신은 소켓 통신과 다르게 클라이언트와 서버가 한 번 연결을 맺은 후 연결을 종료한다. 즉, 계속해서 연결을 유지하지 않으며 리소스의 낭비를 줄일 수 있어 장점이 될 수 있다.</p><ul><li>비상태성(stateless)</li></ul><p>통신이 끝나면 상태를 유지하지 않음. 한 번의 통신이 끝난 이후 상태를 저장하지 않음. 예를 들면 쇼핑몰에서 페이지를 전환할때마다 새로운 커넥션이 생성되기 때문에 계속 로그인을 해야할 수도 있다.</p><p>HTTP는 비연결성과 비상태성이라는 특징 때문에 불특정 다수와의 통신을 가볍게 할 수 있다는 장점이 있다. 하지만 통신할때마다 새로운 커넥션을 생성하고 이전의 상태를 저장하기 않기 때문에 클라이언트가 계속해서 인증해야 한다는 단점이 발생한다. 이러한 단점을 해결하기 위해 쿠키와 세션이 사용될 수 있다.</p><h2 id="1-쿠키-Cookies"><a href="#1-쿠키-Cookies" class="headerlink" title="1. 쿠키(Cookies)"></a>1. 쿠키(Cookies)</h2><p>클라이언트에 저장되는 key: value 형식의 작은 데이터 파일이다. 예를 들면 이름, 값, 만료 날짜, 경로 정보 등이 저장된다. 브라우저 사용자가 웹 사이트를 방문할 때 서버에서 쿠키를 생성하여 사용자의 컴퓨터에 기록한다. <strong>클라이언트가 저장하고 관리하기 때문에 보안에 취약할 수 있다.</strong></p><h3 id="1-1-제약-조건"><a href="#1-1-제약-조건" class="headerlink" title="1-1. 제약 조건"></a>1-1. 제약 조건</h3><ul><li>클라이언트에 총 300개의 쿠키만 저장 가능</li><li>하나의 도메인당 20개의 값만 가질 수 있음</li><li>하나의 쿠키 값은 최대 4096Byte까지 가능</li></ul><h3 id="1-2-쿠키의-작동방식"><a href="#1-2-쿠키의-작동방식" class="headerlink" title="1-2. 쿠키의 작동방식"></a>1-2. 쿠키의 작동방식</h3><p><img src="https://user-images.githubusercontent.com/13075035/74010014-d212fa00-49c7-11ea-97cc-f378ef2542b1.png" alt="https://valuefactory.tistory.com/707"></p><ol><li>브라우저를 통해 웹 페이지 접속</li><li>서버에서 쿠키 생성 및 Set-Cookie를 통해 HTTP 헤더에 쿠키를 포함하여 클라이언트로 전송</li><li>이후의 클라이언트의 모든 요청은 Cookie를 HTTP 헤더에 포함하여 전송</li></ol><h3 id="1-3-쿠키의-사용-예"><a href="#1-3-쿠키의-사용-예" class="headerlink" title="1-3. 쿠키의 사용 예"></a>1-3. 쿠키의 사용 예</h3><ul><li>쇼핑몰 장바구니</li><li>“7일간 보지않기”와 같은 팝업 해제</li><li>아이디 / 비밀번호 저장</li></ul><h2 id="2-세션-Session"><a href="#2-세션-Session" class="headerlink" title="2. 세션(Session)"></a>2. 세션(Session)</h2><p>클라이언트와 서버간의 네트워크 연결이 지속적으로 유지되는 상태. 브라우저가 웹 페이지에 접속하면 서버는 요청한 클라이언트를 유일하게 식별할 수 있는 세션ID를 만들어 부여함. 이 세션 ID를 쿠키로 클라이언트에게 전송하며 클라이언트는 세션 ID만을 쿠키로 가지고 있어 보안상 더 나은 수단이라고 볼 수 있다.</p><h3 id="2-1-세션의-작동방식"><a href="#2-1-세션의-작동방식" class="headerlink" title="2-1. 세션의 작동방식"></a>2-1. 세션의 작동방식</h3><p><img src="https://user-images.githubusercontent.com/13075035/74010724-7a758e00-49c9-11ea-82ae-39292838f535.png" alt="https://valuefactory.tistory.com/707"></p><ol><li>브라우저를 통해 웹 페이지 접속</li><li>서버는 세션 ID(JSESSIONID)를 만들고 DB또는 RAM에서 저장하여 관리함. 그리고 세션 ID를 쿠키로 클라이언트에게 전송.</li><li>이후의 클라이언트의 모든 요청은 세션 ID를 가진 쿠키와 함께 전송되고 서버는 이 세션 ID를 통해 클라이언트를 구분할 수 있음.</li></ol><h3 id="2-2-세션-사용의-예"><a href="#2-2-세션-사용의-예" class="headerlink" title="2-2. 세션 사용의 예"></a>2-2. 세션 사용의 예</h3><ul><li>로그인</li></ul><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>쿠키와 세션은 <strong>저장위치 / 보안 / 생명주기 / 속도</strong>의 방면에서 차이점이 존재한다.</p><ul><li><p>저장위치</p><ul><li>쿠키: 클라이언트</li><li>세션: 서버</li></ul></li><li><p>보안</p><ul><li>쿠키: 클라이언트에 저장되기 때문에 보안에 취약</li><li>세션: 쿠키를 이용해 세션 ID만 저장하고 세션 ID를 통해 서버에서 구분하므로 비교적 안전</li></ul></li><li><p>생명주기</p><ul><li>쿠키: 만료시간이 있지만 파일로 저장되기 때문에 계속해서 남아있을 수 있다.</li><li>세션: 세션도 만료시간이 있지만 브라우저를 종료하면 같이 삭제</li></ul></li><li><p>속도</p><ul><li>쿠키: 실제 정보가 클라이언트에 있어서 빠름</li><li>세션: 실제 정보를 얻기 위해 서버를 거쳐야 함으로 비교적 느림</li></ul></li></ul><hr><p>[참고]<br><a href="https://valuefactory.tistory.com/707" target="_blank" rel="external nofollow noopener noreferrer">https://valuefactory.tistory.com/707</a><br><a href="https://soul0.tistory.com/353" target="_blank" rel="external nofollow noopener noreferrer">https://soul0.tistory.com/353</a><br><a href="https://hees-dev.tistory.com/43" target="_blank" rel="external nofollow noopener noreferrer">https://hees-dev.tistory.com/43</a><br><a href="https://jcon.tistory.com/62" target="_blank" rel="external nofollow noopener noreferrer">https://jcon.tistory.com/62</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/web/cookies-and-session/#disqus_thread</comments>
    </item>
    
    <item>
      <title>안드로이드 AVD 에뮬레이터를 통해 axios 사용할때 발생하는 문제점</title>
      <link>https://jinmay.github.io/2020/05/13/react-native/axios-with-android-avd/</link>
      <guid>https://jinmay.github.io/2020/05/13/react-native/axios-with-android-avd/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;리액트 네이티브를 통해 앱 개발을 할때 http 패키지로서 보통 axios를 사용하는 것 같다. AVD를 띄우고 로컬호스트로 돌아가는 장고 서버에 HTTP 요청을 하려고 했는데 항상 network error를 뱉었다. &lt;strong&gt;유효하지 않은
        
      
      </description>
      
      <content:encoded><![CDATA[<p>리액트 네이티브를 통해 앱 개발을 할때 http 패키지로서 보통 axios를 사용하는 것 같다. AVD를 띄우고 로컬호스트로 돌아가는 장고 서버에 HTTP 요청을 하려고 했는데 항상 network error를 뱉었다. <strong>유효하지 않은 요청이 아니라 아예 요청 자체가 들어가지 않는 현상</strong>이었다. 정확한 문제의 원인은 찾지 못했지만 AVD를 통해 안드로이드 시뮬레이터를 사용중이라면 localhost의 주소를 아래의 주소로 변경해보라는 답을 발견했고 문제를 해결할 수 있었다.</p><p><strong>10.0.2.2</strong></p><hr><p>[참고]<br><a href="https://github.com/axios/axios/issues/973" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/axios/axios/issues/973</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/react-native/axios-with-android-avd/#disqus_thread</comments>
    </item>
    
    <item>
      <title>리액트 네이티브에서 웹 소켓 사용하기</title>
      <link>https://jinmay.github.io/2020/05/13/react-native/rn-how-to-use-websocke-in-react-native/</link>
      <guid>https://jinmay.github.io/2020/05/13/react-native/rn-how-to-use-websocke-in-react-native/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;리액트 네이티브에서 웹 소켓을 사용하기 위해서 node.js의 socket.io 또는 기본으로 제공하는 WebSocket을 이용해야한다.&lt;/p&gt;
&lt;p&gt;처음에는 socket.io를 이용하여 구현하려고 시도했는데 잘되지 않아서 리액트 네이티브의 공식
        
      
      </description>
      
      <content:encoded><![CDATA[<p>리액트 네이티브에서 웹 소켓을 사용하기 위해서 node.js의 socket.io 또는 기본으로 제공하는 WebSocket을 이용해야한다.</p><p>처음에는 socket.io를 이용하여 구현하려고 시도했는데 잘되지 않아서 리액트 네이티브의 공식문서에서 제시하는 것처럼 WebSocket을 이용하여 구현하였다.</p><h2 id="WebSocket-사용법"><a href="#WebSocket-사용법" class="headerlink" title="WebSocket 사용법"></a>WebSocket 사용법</h2><p>일단 웹 소켓 객체를 생성해야 하며, 인자로 주소를 적어준다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://&lt;주소&gt;'</span>);</span><br></pre></td></tr></table></figure><p>각 상황에 사용할 함수들을 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 소켓 연결 시</span></span><br><span class="line">ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">ws.send(<span class="string">'something'</span>); <span class="comment">// 메세지 전송</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메세지 수신</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 에러 발생시</span></span><br><span class="line">ws.onerror = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 소켓 연결 해제</span></span><br><span class="line">ws.onclose = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(e.code, e.reason);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>[참고]<br><a href="https://facebook.github.io/react-native/docs/network#websocket-support" target="_blank" rel="external nofollow noopener noreferrer">https://facebook.github.io/react-native/docs/network#websocket-support</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/react-native/rn-how-to-use-websocke-in-react-native/#disqus_thread</comments>
    </item>
    
    <item>
      <title>리액트 네이티브에서 테스트를 위한 안드로이드 APK 빌드하기</title>
      <link>https://jinmay.github.io/2020/05/13/react-native/how-to-build-react-native-android-for-debug/</link>
      <guid>https://jinmay.github.io/2020/05/13/react-native/how-to-build-react-native-android-for-debug/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;실 기기에 테스트해볼 용도로 apk를 만드는 과정을 정리한다. 사실, 구글 플레이 스토어를 보면 스토어에 올려서 open하지 않고 테스트할 수 있다. 인증을 거치지않는다.&lt;/p&gt;
&lt;p&gt;간단히 정리를 해보면 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;b
        
      
      </description>
      
      <content:encoded><![CDATA[<p>실 기기에 테스트해볼 용도로 apk를 만드는 과정을 정리한다. 사실, 구글 플레이 스토어를 보면 스토어에 올려서 open하지 않고 테스트할 수 있다. 인증을 거치지않는다.</p><p>간단히 정리를 해보면 다음과 같다.</p><ol><li>bundle 파일 생성</li><li>안드로이드 스튜디오로 프로젝트 열기</li><li>apk 생성</li></ol><h2 id="1-bundle-생성"><a href="#1-bundle-생성" class="headerlink" title="1. bundle 생성"></a>1. bundle 생성</h2><p>프로젝트 폴더에서 다음과 같이 입력한다. 각 옵션들이 제대로 적혀 있는지 본다. 간혹 코드의 시작점을 바꾸는 경우가 있는데, 만약 시작점은 변경했다면 –entry-file을 변경해주어야 한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/</span><br></pre></td></tr></table></figure><h2 id="2-안드로이드-스튜디오로-프로젝트-열기"><a href="#2-안드로이드-스튜디오로-프로젝트-열기" class="headerlink" title="2. 안드로이드 스튜디오로 프로젝트 열기"></a>2. 안드로이드 스튜디오로 프로젝트 열기</h2><p>개발중인 리액트 네이티브 앱의 프로젝트 폴더를 연다.</p><h2 id="3-apk-생성"><a href="#3-apk-생성" class="headerlink" title="3. apk 생성"></a>3. apk 생성</h2><p>프로젝트를 열었다면 안드로이드 스튜디오의 상단 Build 옵션에 들어가서 Build Bundle / APK를 확인한다. <strong>APK를 생성하기 위해 Build APK 클릭!</strong></p><p><img src="https://user-images.githubusercontent.com/13075035/72409648-b726de80-37a9-11ea-84fc-05de0e2c19ad.png" alt="image"></p><h2 id="4-생성된-APK-확인"><a href="#4-생성된-APK-확인" class="headerlink" title="4. 생성된 APK 확인"></a>4. 생성된 APK 확인</h2><p>APK 빌드가 완료되면 –assets-dest 옵션에서 명시한 경로에 app-debug.apk 파일이 생성된다.</p><ul><li>경로 : /android/app/build/outputs/apk/debug/</li><li>파일명 : app-debug.apk</li></ul><hr><p>[참고]<br><a href="https://webisfree.com/2018-09-17/react-native-standalone-%EB%B0%A9%EB%B2%95%EC%9C%BC%EB%A1%9C-apk-%EB%A7%8C%EB%93%A4%EA%B8%B0" target="_blank" rel="external nofollow noopener noreferrer">https://webisfree.com/2018-09-17/react-native-standalone-%EB%B0%A9%EB%B2%95%EC%9C%BC%EB%A1%9C-apk-%EB%A7%8C%EB%93%A4%EA%B8%B0</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/react-native/how-to-build-react-native-android-for-debug/#disqus_thread</comments>
    </item>
    
    <item>
      <title>리액트 네이티브에서 스크린 사이즈 구하기</title>
      <link>https://jinmay.github.io/2020/05/13/react-native/rn-how-to-find-size-of-screen/</link>
      <guid>https://jinmay.github.io/2020/05/13/react-native/rn-how-to-find-size-of-screen/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;모바일 어플리케이션을 만들다 보면 각 기기마다 다른 스크린 크기 때문에 머리아픈 경우가 정말 많은 것 같다. 코드로서 화면 크기를 구할 수 있는 방법이 있을까 찾아보았고 정리해본다.&lt;/p&gt;
&lt;h2 id=&quot;화면크기-구하기&quot;&gt;&lt;a href=&quot;#화면크
        
      
      </description>
      
      <content:encoded><![CDATA[<p>모바일 어플리케이션을 만들다 보면 각 기기마다 다른 스크린 크기 때문에 머리아픈 경우가 정말 많은 것 같다. 코드로서 화면 크기를 구할 수 있는 방법이 있을까 찾아보았고 정리해본다.</p><h2 id="화면크기-구하기"><a href="#화면크기-구하기" class="headerlink" title="화면크기 구하기"></a>화면크기 구하기</h2><p><strong>react-native의 Dimensions을 사용하면 된다.</strong> 현재 열린 윈도우 사이즈를 통해 height와 width를 구할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Dimensions &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chartHeight = Dimensions.get(<span class="string">'window'</span>).height;</span><br><span class="line"><span class="keyword">const</span> chartWidth = Dimensions.get(<span class="string">'window'</span>).width;</span><br></pre></td></tr></table></figure><hr><p>[참고]<br><a href="https://stackoverflow.com/questions/53796007/react-native-flex-layout-with-victorychart-chart-fit-the-parent-container" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/53796007/react-native-flex-layout-with-victorychart-chart-fit-the-parent-container</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/react-native/rn-how-to-find-size-of-screen/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DNS]DNS의 기초적인 작동방식</title>
      <link>https://jinmay.github.io/2020/05/13/web/basic-of-dns/</link>
      <guid>https://jinmay.github.io/2020/05/13/web/basic-of-dns/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;DNS는 Domain Name System의 줄임말로써 도메인을 관리하는 시스템이다. DNS의 기본적인 작동방식에 대해서 정리한다.&lt;/p&gt;
&lt;h2 id=&quot;1-DNS-서버에-ip-등록&quot;&gt;&lt;a href=&quot;#1-DNS-서버에-ip-등록&quot; class=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>DNS는 Domain Name System의 줄임말로써 도메인을 관리하는 시스템이다. DNS의 기본적인 작동방식에 대해서 정리한다.</p><h2 id="1-DNS-서버에-ip-등록"><a href="#1-DNS-서버에-ip-등록" class="headerlink" title="1. DNS 서버에 ip 등록"></a>1. DNS 서버에 ip 등록</h2><p><strong>서비스 제공자는 ip를 DNS 서버에 입력해달라고 요청한다.</strong> 즉, <strong>“도메인 example.com은 ip 93.184.216.34를 의미한다”라고 저장해달라고 요청</strong>한다. 그리고 DNS 서버는 해당 정보를 저장한다.</p><p><img src="https://user-images.githubusercontent.com/13075035/75007854-b9234200-54b9-11ea-83ec-721b621e5d03.png" alt></p><h2 id="2-DHCP를-통해-DNS-서버-주소-할당"><a href="#2-DHCP를-통해-DNS-서버-주소-할당" class="headerlink" title="2. DHCP를 통해 DNS 서버 주소 할당"></a>2. DHCP를 통해 DNS 서버 주소 할당</h2><p>DHCP를 통해 클라이언트는 ip 뿐만 아니라 DNS 서버의 주소 / 서브넷 마스크 / 기본 게이트워이 등의 네트워크 정보를 할당 받는다. <strong>DHCP는 컴퓨터가 네트워크에 연결되는 순간 바로 실행되어 네트워크의 정보를 할당 받게 되며, 따라서 어떤 DNS 서버를 사용해야 하는지도 알게 된다.</strong></p><p><a href="http://www.ciokorea.com/tags/25731/DHCP/39337" target="_blank" rel="external nofollow noopener noreferrer">참고</a></p><h2 id="3-DNS로-도메인에-해당하는-ip-요청"><a href="#3-DNS로-도메인에-해당하는-ip-요청" class="headerlink" title="3. DNS로 도메인에 해당하는 ip 요청"></a>3. DNS로 도메인에 해당하는 ip 요청</h2><p>DHCP를 통해 DNS 서버를 알고있기 때문에 접속할 도메인의 ip가 무엇인지 물어본다. 즉, DNS 서버는 example.com의 ip주소인 93.184.216.34를 클라이언트에게 알려준다.</p><p><img src="https://user-images.githubusercontent.com/13075035/75008872-8d558b80-54bc-11ea-8650-7c41f1941ffa.png" alt></p><p>example.com의 ip 주소를 알게된 클라이언트는 ip 주소를 통해 해당 서비스에 접속할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/13075035/75009128-34d2be00-54bd-11ea-8953-7cf9480cbf42.png" alt></p><h2 id="DNS-이용의-장점"><a href="#DNS-이용의-장점" class="headerlink" title="DNS 이용의 장점"></a>DNS 이용의 장점</h2><ul><li>hosts 파일을 관리하는 수고를 덜어준다.</li><li>도메인의 ip 주소가 변경되어도 DNS 서버에서만 바꾸면된다.</li></ul><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li><p>클라이언트가 네트워크에 연결되는 순간 DHCP가 작동하여 ip를 물어볼 DNS 서버를 알게된다.</p></li><li><p>네이버에 접속하는 순간 다음의 두 과정을 거친다.</p><ol><li>DNS 서버에게 naver.com의 ip 주소를 물어본다.</li><li>DNS 서버로부터 naver.com의 ip 주소를 받고 해당 ip로 접속한다.</li></ol></li></ul><hr><p>[참고]<br><a href="https://www.youtube.com/watch?v=iM07I1X7qkg&amp;list=PLuHgQVnccGMCI75J-rC8yZSVGZq3gYsFp&amp;index=6" target="_blank" rel="external nofollow noopener noreferrer">https://www.youtube.com/watch?v=iM07I1X7qkg&amp;list=PLuHgQVnccGMCI75J-rC8yZSVGZq3gYsFp&amp;index=6</a><br><a href="https://jwprogramming.tistory.com/35" target="_blank" rel="external nofollow noopener noreferrer">https://jwprogramming.tistory.com/35</a><br><a href="http://www.ciokorea.com/tags/25731/DHCP/39337" target="_blank" rel="external nofollow noopener noreferrer">http://www.ciokorea.com/tags/25731/DHCP/39337</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/web/basic-of-dns/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[JWT]인증(authentication)에 보편적으로 사용되는 JWT에 대해서</title>
      <link>https://jinmay.github.io/2020/05/13/web/basic-of-jwt/</link>
      <guid>https://jinmay.github.io/2020/05/13/web/basic-of-jwt/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/13075035/74138722-7057c780-4c35-11ea-8186-736263e14289.png&quot; alt=&quot;jwt.io&quot;&gt;&lt;/p&gt;
&lt;h2 id=
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://user-images.githubusercontent.com/13075035/74138722-7057c780-4c35-11ea-8186-736263e14289.png" alt="jwt.io"></p><h2 id="1-사용자-인증정보를-관리하는-두-가지"><a href="#1-사용자-인증정보를-관리하는-두-가지" class="headerlink" title="1. 사용자 인증정보를 관리하는 두 가지"></a>1. 사용자 인증정보를 관리하는 두 가지</h2><ul><li>세션 기반 인증</li></ul><p><strong>서버 기반 인증</strong>이라고 불리기도 한다. 과거부터 사용해오는 방법이며 이름에서 알 수 있듯이 유저가 서비스에 로그인을 하면 서버는 인증 정보를 계속해서 사용해야 하기 위해 메모리나 데이터 베이스에 저장하여 관리하는 방식이다. 세션 기반 방식은 정말 정말 널리 쓰이지만 크게 볼때 두 가지의 문제가 존재한다.</p><p>첫 번째, 서비스에 로그인 중인 유저가 많아지면 세션을 유지하기 위해 더 많은 메모리 / 데이터 베이스의 자원을 사용하게 됨으로 성능에 무리를 줄 수 있다. 두 번째, 서버의 확장이 어려워진다. 첫 번째 이유를 확장해 생각해볼때 분산 환경에서 세션을 사용하려면 분산된 서비스간에 세션의 정보가 동기화 되어야 함으로 구현의 복잡도가 매우 커질 것이다.</p><ul><li>토큰 기반 인증</li></ul><p>HTTP의 두 가지 특성 - 무상태성 / 비연결성 - 에 따라 HTTP는 상태를 가지지 않는다. 그렇기 때문에 <strong>로그인한 상태</strong>를 파악하기 위해 세션 기반 인증을 사용하는 것인데, 이에 반해 토큰 기반 인증은 서버 측에서 상태를 유지하지 않고 로그인 시에 발급한 토큰을 통해 유저가 인증과정을 밟는 것이다. 서버의 구성이 분산되어 있더라도 유저는 동일한 토큰을 통해 서버에 요청할 수 있고, 서버는 데이터 베이스와 통신할 필요 없이 인증을 유지할 수 있어서 확장하기에 편해질 수 있다. 또한 모바일 어플리케이션에서 인증을 구현하기에 매우 편리하다는 장점이 있다.</p><h2 id="2-토큰-관리"><a href="#2-토큰-관리" class="headerlink" title="2. 토큰 관리"></a>2. 토큰 관리</h2><ol><li>브라우저 스토리지에 저장</li></ol><p>유저가 로그인하면 서버는 응답정보에 토큰을 넣어 전달한다. 클라이언트는 브라우저의 localStorage나 sessionStorage에 저장하여 다음 번 요청때 요청 헤더에 토큰을 붙여 보낼 수 있다. 구현하기 매우 쉽지만 보안적으로는 큰 구멍이 존재하는데, 자바스크립트를 통해 웹 브라우저의 스토리지에 접근할 수 있기 때문이다.</p><ol start="2"><li>쿠키에 저장</li></ol><p>쿠키를 전송 수단으로써 사용한다. 서버 측에서 응답할때 쿠키 설정에 httpOnly 옵션을 활성화하면, 네트워크 통신 상에서만 해당 쿠키가 붙게 된다. 따라서, 자바스크립트가 브라우저를 통해 토큰 값을 사용할 수 없다. 그렇다고 보안상의 문제가 없는 것은 아니며 CSRF 공격의 위험성이 발생할 수 있다.</p><h2 id="3-JWT란"><a href="#3-JWT란" class="headerlink" title="3. JWT란?"></a>3. JWT란?</h2><p>JWT는 Json Web Token의 약자로써 JSON 문자열로 이루어진 토큰을 의미한다. 토큰 기반 인증 기술 중 하나이며 다른 토큰들과는 다르게 토큰 그 자체가 의미를 가지는 Claim 기반의 토큰이다.</p><h3 id="4-JWT의-구조"><a href="#4-JWT의-구조" class="headerlink" title="4. JWT의 구조"></a>4. JWT의 구조</h3><p><img src="https://user-images.githubusercontent.com/13075035/74138842-a5641a00-4c35-11ea-9c7c-8a0cff73164c.png" alt="https://jwt.io/introduction/"></p><p><strong>Header / Payload / Signature</strong> - 세 개의 섹션으로 이루어져있다.</p><h3 id="4-1-Header"><a href="#4-1-Header" class="headerlink" title="4-1. Header"></a>4-1. Header</h3><p>JWT 웹 토큰의 헤더 정보</p><ul><li>alg: 해시 알고리즘. 데이터 자체를 암호화 하는 것이 아니라 발급된 토큰을 검증하기 위해 사용한다.</li><li>typ: 토큰의 타입. JWT만 사용가능하다.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line"><span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Payload"><a href="#4-2-Payload" class="headerlink" title="4-2. Payload"></a>4-2. Payload</h3><p>데이터가 저장되는 부분. 3가지의 Claim 데이터가 있다.</p><ul><li>Reserved Claim</li><li>Public Claim</li><li><strong>Private Claim</strong> : 사용자 정의 Claim으로써 아래와 같이 정보를 저장한다.</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line"><span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-Signature"><a href="#4-3-Signature" class="headerlink" title="4-3. Signature"></a>4-3. Signature</h3><p>데이터의 무결성과 변조 방지를 위한 서명. Header와 Payload를 합친 후 Secret Key와 함께 Header에 명시한 알고리즘으로 해싱된 값이다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><h3 id="4-4-인증-과정"><a href="#4-4-인증-과정" class="headerlink" title="4-4. 인증 과정"></a>4-4. 인증 과정</h3><p><img src="https://user-images.githubusercontent.com/13075035/74139787-528b6200-4c37-11ea-9177-6d98596c6457.png" alt="image"></p><ol><li>클라이언트가 로그인을 한다.</li><li>서버는 사용자의 정보를 확인 후 토큰을 생성하여</li><li>클라이언트에게 토큰을 전달한다.</li><li>로그인 후 모든 요청때, 헤더에 토큰 값을 붙여 전송한다.</li><li>토큰을 확인하여 유효한 토큰일 경우 요청을 처리한 뒤 응답한다.</li></ol><h3 id="4-5-단점"><a href="#4-5-단점" class="headerlink" title="4-5. 단점"></a>4-5. 단점</h3><ul><li>Payload 부분에 데이터를 저장하기 때문에 데이터가 많아질 경우 토큰의 길이가 증가한다.</li><li>Payload의 데이터는 암호화가 아닌 base64로만 인코딩을 거친 값이다. 즉, 따로 암호화를 수행하거나 보안에 민감한 데이터를 포함하지 않아야만 한다.</li><li>무상태(stateless)하기 때문에 한 번 생성한 토큰을 임의로 삭제할 수 없다. 꼭 토큰 만료시간을 설정하여 대비해야한다.</li></ul><hr><p>[참고]<br><a href="https://jwt.io/introduction/" target="_blank" rel="external nofollow noopener noreferrer">https://jwt.io/introduction/</a><br><a href="https://sanghaklee.tistory.com/47" target="_blank" rel="external nofollow noopener noreferrer">https://sanghaklee.tistory.com/47</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/web/basic-of-jwt/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DNS]도메인 이름의 구조</title>
      <link>https://jinmay.github.io/2020/05/13/web/constructure-of-domain-name/</link>
      <guid>https://jinmay.github.io/2020/05/13/web/constructure-of-domain-name/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/13075035/75011772-c3e2d480-54c3-11ea-8e2d-3976d52e3a33.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;도메인 이름은 네 가지로
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://user-images.githubusercontent.com/13075035/75011772-c3e2d480-54c3-11ea-8e2d-3976d52e3a33.png" alt></p><p>도메인 이름은 네 가지로 나눌 수 있다.</p><ul><li>Root</li><li>Top-level</li><li>Second-level</li><li>Sub</li></ul><p>그리고 DNS에서 통용되는 규칙 몇 가지가 있다.</p><ul><li>직속 하위 레벨의 DNS 서버의 리스트를 알고 있어야 한다.</li><li>모든 컴퓨터는 적어도 Root 도메인의 DNS 서버를 알고 있어야 한다.</li></ul><h2 id="도메인-서버를-찾아과는-과정"><a href="#도메인-서버를-찾아과는-과정" class="headerlink" title="도메인 서버를 찾아과는 과정"></a>도메인 서버를 찾아과는 과정</h2><p>위와 같이 blog.example.com 이라는 도메인에 접속하려고 할 때, 한 번에 blog.example.com를 가진 DNS 서버를 찾는 것은 어렵기 때문에 여러 레벨의 도메인 서버를 거쳐가기 마련이다.</p><p><img src="https://user-images.githubusercontent.com/13075035/75014946-d3b1e700-54ca-11ea-90cd-8794aeb7f464.png" alt></p><p>클라이언트가 blog.example.com의 ip 주소를 알아가는 과정을 의식의 흐름대로 정리해보면 다음과 같다.</p><ol><li>Root 도메인의 DNS 서버를 알고 있으며, blog.example.com의 ip 주소를 물어본다.</li><li>Root 도메인 서버는 blog.example.com의 ip를 모르기 때문에 하위 레벨인 .com의 DNS 서버를 알려준다.</li><li>클라이언트는 다시 .com의 DNS 서버에게 blog.example.com를 물어보지만 모르기 때문에 하위 레벨인 .example(2nd level)의 DNS 서버를 알려준다.</li><li>.example를 관리하는 2nd level의 DNS 서버도 blog.example.com를 모르기 때문에 blog라는 서브 도메인을 관리하는 DNS 서버를 알려준다.</li><li>blog를 관리하는 DNS 서버는 blog.example.com의 ip 주소를 알고 있기 때문에 클라이언트에게 알려준다.</li></ol>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/web/constructure-of-domain-name/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[selenium]셀레니움 사용시 특정 element의 클릭이 되지 않을때 대처법</title>
      <link>https://jinmay.github.io/2020/05/13/python/selenium-click-does-not-work/</link>
      <guid>https://jinmay.github.io/2020/05/13/python/selenium-click-does-not-work/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;셀레니움을 통해 특정 element를 클릭하려고 할때 보통은 아래와 같은 방법을 사용하곤 한다.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
        
      
      </description>
      
      <content:encoded><![CDATA[<p>셀레니움을 통해 특정 element를 클릭하려고 할때 보통은 아래와 같은 방법을 사용하곤 한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body.find_element_by_class_name(<span class="string">"btn_more"</span>).click()</span><br></pre></td></tr></table></figure><p>click() 함수를 사용하게 되면 간단하게 해당 element를 클릭할 수 있는데, 원인 미상으로 가끔씩 클릭이 되지 않는 상황이 발생했다.</p><p>클릭을 구현하는 방법으로는 click() 함수와 submit() 함수를 사용할 수 있지만, 위의 상황처럼 보통의 방법으로는 클릭이 수행되지 않을때 아래의 코드 처럼 구현하면 문제 없이 사용할 수 있었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">"TOTAL"</span>).send_keys(Keys.ENTER)</span><br></pre></td></tr></table></figure><p>하지만,,<br>위의 방법을 통해도 클릭이 되지 않을 수 있는데, 아래와 같은 방법을 시도해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_id(<span class="string">"TOTAL"</span>)</span><br><span class="line">driver.execute_script(<span class="string">"arguments[0].click();"</span>, element)</span><br></pre></td></tr></table></figure><hr><p>[참고]<br><a href="https://wkdtjsgur100.github.io/selenium-does-not-work-to-click/" target="_blank" rel="external nofollow noopener noreferrer">https://wkdtjsgur100.github.io/selenium-does-not-work-to-click/</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/python/selenium-click-does-not-work/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[python]파이썬의 타입 힌트</title>
      <link>https://jinmay.github.io/2020/05/13/python/python-type-hint/</link>
      <guid>https://jinmay.github.io/2020/05/13/python/python-type-hint/</guid>
      <pubDate>Wed, 13 May 2020 09:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;파이썬은 동적 타이핑 언어로서 코드를 작성하는 시점이 아닌 프로그램이 진행될때 자료형이 정해진다. 파이썬 버전 3.5부터 도입되기 시작되었으며 타입 힌트를 적용할 수 있는 범위가 점진적으로 넓어지고 있다.&lt;/p&gt;
&lt;h2 id=&quot;typing-패키지
        
      
      </description>
      
      <content:encoded><![CDATA[<p>파이썬은 동적 타이핑 언어로서 코드를 작성하는 시점이 아닌 프로그램이 진행될때 자료형이 정해진다. 파이썬 버전 3.5부터 도입되기 시작되었으며 타입 힌트를 적용할 수 있는 범위가 점진적으로 넓어지고 있다.</p><h2 id="typing-패키지"><a href="#typing-패키지" class="headerlink" title="typing 패키지"></a>typing 패키지</h2><p>파이썬에서 타입 힌트를 사용하기 위해 typing 모듈을 임포트해야 한다. 물론 밑의 예시처럼 *를 써서 모든 기능을 가져오는 것은 좋지 않다. 실제 사용시에는 필요한 것만 임포트할 수 있도록 한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h2 id="1-변수에-사용하기"><a href="#1-변수에-사용하기" class="headerlink" title="1. 변수에 사용하기"></a>1. 변수에 사용하기</h2><p>타입 힌트가 등장했던 3.5 버전에서는 사용이 불가하다. 3.6 이상부터 사용할 수 있다. 변수명 뒤에 자료형을 적어준다. 어떻게 보면 golang과 비슷한거 같기도 하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text: str = <span class="string">'Hello world!!'</span></span><br><span class="line">num: int = <span class="number">123</span></span><br></pre></td></tr></table></figure><p>만약 사용자가 직접 만든 클래스가 있다면 클래스의 인스턴스를 생성할때에도 적용할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">ins_a: Test = Test()</span><br></pre></td></tr></table></figure><h2 id="2-함수의-인자에-사용하기"><a href="#2-함수의-인자에-사용하기" class="headerlink" title="2. 함수의 인자에 사용하기"></a>2. 함수의 인자에 사용하기</h2><p>함수의 인자와 리턴에 타입 힌트를 적용할 수 있다. 어떠한 자료형의 인자를 받고 함수의 리턴형을 유추할 수 있도록 돕는다. 아래의 예시는 문자열 인자 title과 숫자형 인자 num을 사용하며 이 함수의 리턴형은 str이어야한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_func</span><span class="params">(title: str, num: int)</span> -&gt; str:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>만약 특정한 반환값이 없는 함수라면 이렇게 할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_func1</span><span class="params">(text: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">  print(text)</span><br></pre></td></tr></table></figure><h2 id="3-리스트-딕셔너리-튜플"><a href="#3-리스트-딕셔너리-튜플" class="headerlink" title="3. 리스트 / 딕셔너리 / 튜플"></a>3. 리스트 / 딕셔너리 / 튜플</h2><p>리스트 / 딕셔너리 / 튜플을 타입 힌트로 표현하는 방법은 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num_list = List[int]</span><br><span class="line">test_dict = Dict[str, int]</span><br><span class="line">test_tuple = Tuple(int)</span><br></pre></td></tr></table></figure><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>파이썬 3.5부터 등장한 타입 힌트에 대해서 아주 간단하게 정리했다. 함수와 변수에서 사용되는 타입 힌트에 대해서만 나열했지만 사실은 더 많은 기능들이 존재한다. 또한 mypy라는 툴을 pip로 설치하여 같이 사용하면 정적 타입 검사기로써 사용할 수 있어 타입 힌트를 사용하는 데에 도움을 줄 수 있을 것이다.</p><hr><p>[참고]<br><a href="https://item4.blog/2017-09-14/Python-Typing-with-mypy/" target="_blank" rel="external nofollow noopener noreferrer">https://item4.blog/2017-09-14/Python-Typing-with-mypy/</a><br><a href="https://minwook-shin.github.io/python-type-hint-typing-using-mypy/" target="_blank" rel="external nofollow noopener noreferrer">https://minwook-shin.github.io/python-type-hint-typing-using-mypy/</a><br><a href="https://lewisxyz000.tistory.com/35" target="_blank" rel="external nofollow noopener noreferrer">https://lewisxyz000.tistory.com/35</a></p>]]></content:encoded>
      
      <comments>https://jinmay.github.io/2020/05/13/python/python-type-hint/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
